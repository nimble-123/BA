\section{Fallbeispiel SAP UI5 Applikation}\label{fallbeispiel}
In diesem Kapitel wird das prototypische Fallbeispiel vorgestellt. Eine kurze Erläuterung des Front- und Backends der Applikation wird in der Beschreibung gegeben. Im Unterkapitel 3.2 werden die genutzten Hilfsmittel in ihrer Funktion und Zugehörigkeit zum Fallbeispiel erklärt. Danach folgt die Implementierung selbst in der Anhand von Screendumps und Applikationscode beschrieben wird wie das Fallbeispiel nach dem Model-View-Controller Muster umgesetzt worden ist.

\subsection{Beschreibung}
Die prototypische SAP UI5 Applikation ist dazu gedacht im Rahmen eines SAP SCM Systems eine Übersicht über die Produkte zu geben. Das Frontend wird im Browser ausgeführt, wohingegen das Backend von einem ABAP AS repräsentiert wird der zusätzlich noch durch ein SAP Netweaver Gateway geschützt ist. Nach Auswahl eines Produktes sollen weitere Details angezeigt werden. Auf dieser Detail Seite sind Informationen wie Name, Material Nummer, Brutto/Netto Preis und Lagermenge einsehbar. Außerdem können über zwei Reiter Charts angezeigt werden. Die erste Chart soll anhand historischer Absatzdaten eine Prognose über zukünftige Absatzzahlen geben. In der zweiten Chart wird eine Bestellvorschau bereitgestellt.

\subsection{Hilfsmittel}
Dieses Kapitel soll kurz aufzeigen welche Hilfsmittel zur Realisierung des Prototypen verwendet wurden. Zum einen gehört die Entwicklungsumgebung Eclipse dazu. Weiter wurden die Chrome Developer Tools des Chrome Browser genutzt, sowie das Tool Wireframesketcher. In den folgenden Unterkapitel werden diese Tools kurz vorgestellt.

\subsubsection{Eclipse}
Zum Einsatz in der Implementierung des Fallbeispiels ist die quelloffene integrierte Entwicklungsumgebung Eclipse gekommen. Diese IDE wurde von der Eclipse Foundation entwickelt und ist plattformunabhängig. Geschrieben wurde Eclipse in Java. Die aktuelle Version 4.4 ist am 25. Juni 2014 erschienen und trägt den Namen Luna. Eclipse zeichnet sich durch ein Plugin System aus mit welchem eine erhebliche Anzahl an Anwendungsfälle mit dieser IDE abgedeckt werden können.(vgl. \cite{WikiEclipse2014}) So auch die Entwicklung von SAP UI5 Applikationen. Dafür hat die SAP AG ein spezielles SAP UI5 Plugin bereitgestellt. Entsprechende Plugins müssen nicht umständlich über eine Webseite bezogen und installiert werden. Sie können über die integrierte Plugin Funktion installiert und eingerichtet werden. Eine URL zum Plugin ist vollkommen ausreichend. Für die Entwicklung von SAP UI5 Applikationen wurden folgende Plugins benötigt:
	
	\vspace{1em}
    \begin{compactitem}
	    \item UI Development Toolkit for HTML5
	    \item ABAP Development Tools for SAP NetWeaver
	    \item (SAP HANA Tools)	    
    \end{compactitem}
	\vspace{1em}

Bezogen werden können diese Plugins mittels der URL \url{https://tools.hana.ondemand.com/luna} und der erwähnten Plugin Funktion von Eclipse. Neben dem reinen Code Editor werden allerdings weitere Tools benötigt um eine SAP UI5 Applikation zu entwickeln.

\subsubsection{Chrome Developer Tools}
Die SAP UI5 Dokumentation schlägt vor zum Testen der entwickelten Applikationen Google Chrome oder Mozilla Firefox anstatt Microsoft Internet Explorer zu verwenden. Das vorliegende Fallbeispiel wurde mit Google Chrome getestet. Google Chrome bietet dazu ein Tool mit dem Namen Developer Tools, welches in jeder Standard Installation des Browsers enthalten ist. Mit diesem Tool lässt sich beispielsweise das DOM der aktuellen Webseite anzeigen. Weiter kann man JavaScript Breakpoints setzen und so effizient debuggen. Es bietet eine Konsole um direkte JavaScript Befehle abzusetzen und die Ergebnisse zu analysieren. Um eine Anwendungen nicht zwingend auf verschiedenen Endgeräten, mit verschiedenen Displaygrößen, testen zu müssen lassen sich jegliche Art von Endgeräten mit den Developer Tools emulieren.(vgl. \cite{DevTools})

%\subsubsection{Neptune Application Designer}

\subsubsection{Wireframesketcher}
// Wireframing als Prototyping\\
// Abbildung Wireframesketcher\\

\subsection{Implementierung}
Es wird die Implementierung des Fallbeispiels beschrieben. Jede Schicht des Model-View-Controller Musters hat dabei ihr eigenes Unterkapitel. Damit werden jeweils die wichtigen Schlüsselpunkte der Applikation offen gelegt. Mehrfach verwendeter Code wird in dem Kapitel bewusst nicht gezeigt um keine unnötige Komplexität zu erzeugen. Der vollständige Programmcode ist im Anhang zu finden.

\subsubsection{Vorbereitungen}
In Eclipse wird ein neues Projekt als SAP UI5 Applikation erstellt. Nach dem Anlegen einer neuen SAP UI5 Applikation ohne initial View findet man im Projekt Explorer von Eclipse die generierte Verzeichnisstruktur vor. In dieser Struktur finden sich zu beginn drei Verzeichnisse. Das \textit{META-INF} Verzeichnis wird automatisch von Eclipse erstellt und dient lediglich als Informationsspeicher für den Umgang des Projekt im Zusammenspiel mit einigen Java Tools. Daneben existiert das \textit{WEB-INF} Verzeichnis. In den Dateien dieses Verzeichnisses stehen Anweisungen für das Deployment des Projekts, sowie sind vorkompilierte Klassendateien und Hilfsbibliotheken in Unterordnern hinterlegt. Außerdem enthält das Projekt auch das \textit{WebContent} Verzeichnis, welches als Arbeitsverzeichnis für das gesamte Projekt gilt. Dort sind sämtliche statische Dateien, wie z.B. HTML Dokumente, JavaScript und XML Dateien oder auch andere Ressourcen wie Bilder und Texte abgelegt. Im Arbeitsverzeichnis werden für die spätere ordentliche Struktur Verzeichnisse für die unterschiedlichen Zwecke angelegt -- \textit{i18n}, \textit{model}, \textit{util} und \textit{view}. Im \textit{i18n} Verzeichnis liegen später die Sprachdateien um die Applikation lokalisiert auszuliefern. Das \textit{model} und \textit{view} Verzeichnis sind selbsterklärend. Im \textit{util} Verzeichnis werden Helferskripte hinterlegt wie z.B. \textit{Formatter} oder \textit{Grouper} Skripte. Als nächstes folgt die Implementierung der Views.

\subsubsection{View}
Zu beginn wird in der Datei \textit{index.html} durch ein \textit{title}-Element direkt unter dem letzten \textit{meta}-Element der Seitentitel festgelegt. Innerhalb der folgenden \textit{script}-Elemente werden Eigenschaften der SAP UI5 Applikation eingestellt. An dieser Stelle müssen die verwendeten SAP UI5 JavaScript Bibliotheken und die Art und Weise der Datenbindung des Modells hinzugefügt werden. In dem leeren \textit{script}-Block wird dann letztendlich die Anweisung geschrieben, welche den \textit{Component Container} lädt und damit das Bootstrapping der Applikation in Gang setzt. Die Datei \textit{index.html} ist in verkürzter Form in Listing \ref{lst:index.html} zu sehen.

	\begin{lstlisting}[frame=htrbl, caption=Bootstrapping der SAP UI5 Applikation, label=lst:index.html]
...
	<script
		id="sap-ui-bootstrap"
		src="resources/sap-ui-core.js"
		data-sap-ui-theme="sap_bluecrystal"
		data-sap-ui-libs="sap.m, sap.ui.layout"
		data-sap-ui-preload="" 
		data-sap-ui-xx-bindingSyntax="complex"
		data-sap-ui-resourceroots='{
			"abat.Mockup": "./"
		}' >
	</script>

	<script>
		new sap.ui.core.ComponentContainer({
			name : "abat.Mockup"
		}).placeAt("content");
	</script>
...
	\end{lstlisting}
	
\paragraph{Component Container}$\;$ \\
Der eben erwähnte \textit{Component Container} wird nach den Änderungen an der Datei \textit{index.html} im Arbeitsverzeichnis als \textit{Component.js} erstellt. Der \textit{Component Container} ist ein Sammelbehälter für die unterschiedlichen SAP UI5 Komponenten. Er beinhaltet neben der Deklaration und Initialisation der Model auch die Root View. Diese Root View ist die unterste Schicht des View Stacks. In ihr werden sämtliche weiteren Views platziert. Bei der Initialisierung wird auf die Datei \textit{App.view.js} verwiesen. Zu den verwendeten Models sei an dieser Stelle noch nichts näher erläutert da dies im nächsten Kapitel folgt. Als Rückgabewert liefert dieser \textit{Component Container} dann die Root View mit ihren Elementen. Listing \ref{lst:Component.js} zeigt auszugweise die Datei \textit{Component.js} und die Erstellung der Root View.

	\begin{lstlisting}[frame=htrbl, caption=Auszug aus der Component.js, label=lst:Component.js]
jQuery.sap.declare("abat.Mockup.Component");
sap.ui.core.UIComponent.extend("abat.Mockup.Component", {
	createContent : function() {

		// create root view
		var oView = sap.ui.view({
			id : "app",
			viewName : "abat.Mockup.view.App",
			type : "JS",
			viewData : { component : this }
		});

		// model declaration and initialisation goes here
		...

		return oView;
	}
});
	\end{lstlisting}
	
\paragraph{Root View}$\;$ \\
Die Datei \textit{App.view.js} repräsentiert die Root View aus dem \textit{Component Container}. Der Rückgabewert ist eine \textit{Shell} genannte SAP UI5 Komponente. Dieser \textit{Shell} wird ein Titel über das Lokalisierungsmodell zugewiesen. Dazu später mehr. Ausdrücke die einen String darstellen können so leicht mit einer lokalen Version des Wertes ersetzt werden. Des Weiteren verlangt die \textit{Shell} eine \textit{App} Komponente. Diese Komponente wird am Anfang der Datei \textit{App.view.js} erzeugt. Es handelt sich bei dem Prototyp um eine \textit{App} Komponente namens \textit{SplitApp}. Eine \textit{SplitApp} besitzt eine Haupt- und Detailseite. Diese werden auch innerhalb der \textit{App.view.js} erzeugt und der \textit{SplitApp} Komponente zugewiesen. Allerdings verweisen die Haupt- und Detailseite auch wieder auf eigene Dateien auf Grund des Kapselungsprinzip zum Zwecke der besseren Wartbarkeit. Listing \ref{lst:App.view.js} zeigt den gerade beschriebenen Vorgang.

	\begin{lstlisting}[frame=htrbl, caption=Root View der Applikation, label=lst:App.view.js]
...
    // create app
    this.app = new sap.m.SplitApp();

    // load the master page
    var master = sap.ui.xmlview("Master", "abat.Mockup.view.Master");
    master.getController().nav = this.getController();
    this.app.addPage(master, true);

    return new sap.m.Shell("Shell", {
      title : "{i18n>ShellTitle}",
      showLogout : false,
      app : this.app
    });
  }
});
	\end{lstlisting}
	
\paragraph{Hauptseite}$\;$ \\
Die \textit{Master.view.xml} wird nicht, wie der Dateiname schon schließen lässt, gleich der Root View im JavaScript sondern im XML Format erstellt. Sie beinhaltet die Komponenten, die in der \textit{SplitApp} die Hauptseite darstellt. Realisiert wird das über die Komponente \textit{Page}. In der \textit{Page} liegen widerum weitere Komponenten die das Aussehen der Hauptseite definieren. Durch einen \textit{customHeader} inklusive einer \textit{Bar} und einem \textit{Image} wird ein Firmenlogo in die Hauptseite ganz oben eingefügt. Ein \textit{subHeader} mit einer \textit{Bar} und einem \textit{SearchField} sind für eine Suchfunktion innerhalb der Liste gesetzt. Eine \textit{List} implementiert eine vertikale Liste, die mit Komponenten vom Typ \textit{ObjectListItem} befüllt wird. Das \textit{ObjectListItem} dient in dem Fall als Formatvorlage für die tatsächlichen Daten die später aus dem Model bezogen werden. Abgeschlossen wird die Seite mit der \textit{footer} Komponente in der eine \textit{Bar} und ein \textit{Button} eingelassen sind. Der Button soll eine Gruppierungsfunktion für die Liste möglich machen. Listing \ref{lst:Master.view.xml} enthält die erläuterte Struktur der Hauptseite im XML Format.

	\begin{lstlisting}[frame=htrbl, caption=Hauptseite der SplitApp, label=lst:Master.view.xml]
<core:View
  controllerName="abat.Mockup.view.Master"
  xmlns="sap.m"
  xmlns:core="sap.ui.core" >
  <Page>
    <customHeader><Bar><contentLeft>
          <Image src="img/logo.png" width="173px" height="30px"></Image>
    </contentLeft></Bar></customHeader>
    <subHeader><Bar><contentLeft>
        <SearchField
          search="handleSearch"
          width="100%" >
        </SearchField>
    </contentLeft></Bar></subHeader>
    <List id="list"
      mode="{device>/listMode}"
      select="handleListSelect"
      items="{/Products}" >
      <ObjectListItem type="{device>/listItemType}"
        press="handleListItemPress"
        title="{MaterialName}"
        number="{Quantity}"
        numberUnit="{i18n&gt;QuantityUnit}"
        numberState="{parts : [ 'Quantity', 'MinimalQuantity' ],
                formatter : 'abat.Mockup.util.Formatter.numberState'}" >
        <attributes><ObjectAttribute text="{MatId}" /></attributes>
        <firstStatus><ObjectStatus text="{Status}"
            state="{path: 'Status',
            formatter: 'abat.Mockup.util.Formatter.statusState'}" />
        </firstStatus>
      </ObjectListItem>
    </List>
    <footer>
    <Bar><contentRight><Button icon="sap-icon://group-2"
        press="handleViewSettings" />
    </contentRight></Bar>
    </footer>
  </Page>
</core:View>
	\end{lstlisting}

\paragraph{Detailseite}$\;$ \\
Die Detailseite wird zwar in der Root View nicht direkt deklariert, dies erfolgt innerhalb eines Controllers, aber zur Vollständigkeit wird sie kurz erläutert. Vom generellen Aufbau gleicht sie der \textit{Master.view.xml}. Sie ist auch im XML Format definiert, enthält aber ein paar andere Komponenten. Sämtliche Komponenten liegen wieder in einer \textit{Page}. Begonnen wird mit einem \textit{ObjectHeader}, dieser setzt den Titel des anzuzeigenden Listeneintrags der Hauptseite. Daneben werden noch weitere Information aufgelistet. Unter diesem Kopfteil ist eine \textit{IconTabBar} platziert. Diese Leiste enthält zwei Einträge um so später Zugriff auf die beiden Charts zu erhalten. Um auch hier wieder zu kapseln besitzen die Einträge nur ein Bild und einen verweis auf sogenanntes Fragment. Mit diesem Fragment wird jeweils das Chart definiert. Bedeutet die Art des Diagramms und die jeweils dazu spezifischen Einstellungen. Auf ein Listing wird an dieser Stelle verzichtet.

\subsubsection{Model und Controller}
// die Verbindung von beiden Anhand von Coding zeigen\\
// TODO: OData Modell einbinden\\
// Datenfluss anreißen und auf Analyse verweisen\\
// Listing \ref{lst:modelbinding}
	\begin{lstlisting}[frame=htrbl, caption=Model an die Root View binden, label=lst:modelbinding]
...
// JSON Modell an die Root View binden
var oModel = new sap.ui.model.json.JSONModel("model/mock.json");
oView.setModel(oModel);

// OData Modell
var oModel = new sap.ui.model.odata.ODataModel(<URL>);
oView.setModel(oModel);

// I18N(Lokalisierung) Modell
var i18nModel = new sap.ui.model.resource.ResourceModel({
  bundleUrl : "i18n/messageBundle.properties"
});
oView.setModel(i18nModel, "i18n");

// Geraetespezifisches Modell
var deviceModel = new sap.ui.model.json.JSONModel({
  isPhone : jQuery.device.is.phone,
  listMode : (jQuery.device.is.phone) ? "None" : "SingleSelectMaster",
  listItemType : (jQuery.device.is.phone) ? "Active" : "Inactive"
});
deviceModel.setDefaultBindingMode("OneWay");
oView.setModel(deviceModel, "device");
...
	\end{lstlisting}

\subsubsection{Backend}
// ABAP Stack der den RESTful Service bereitstellt zeigen\\
// Beispielhafte Implementation des HTTP Responses\\

\subsubsection{Deployment}
// Kurze Step-by-Step Erklärung wie die SAP UI5 Applikation aus Eclipse an den ABAP AS deployed wird\\
// Den Service zeigen den der deploy Vorgang automatisch generiert und in welchem später (FAZIT) dann die CRUD Operationen auf der Backend Seite implementiert werden\\
